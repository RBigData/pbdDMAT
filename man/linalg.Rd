% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/ddmatrix_algebra.R, R/ddmatrix_solve.r
\docType{methods}
\name{linlalg}
\alias{chol,ddmatrix-method}
\alias{eigen,ddmatrix-method}
\alias{linlalg}
\alias{lu,ddmatrix-method}
\alias{solve,ddmatrix,ANY-method}
\alias{solve,ddmatrix,ddmatrix-method}
\title{Linear Algebra Functions}
\usage{
\S4method{chol}{ddmatrix}(x)

\S4method{lu}{ddmatrix}(x)

\S4method{eigen}{ddmatrix}(x, symmetric, only.values = FALSE)

\S4method{solve}{ddmatrix,ANY}(a)

\S4method{solve}{ddmatrix,ddmatrix}(a, b)
}
\arguments{
\item{x,a,b}{numeric distributed matrices.  If applicable, \code{a}
and \code{b} must be on the same BLACS context and have the same blocking
dimension.}

\item{symmetric}{logical, if \code{TRUE} then the matrix is assumed to be
symmetric and only the lower triangle is used.  Otherwise \code{x} is
inspected for symmetry.}

\item{only.values}{logical, if \code{TRUE} then only the eigenvalues are
returned.  Otherwise both eigenvalues and eigenvectors are returned.}

\item{a,b}{numeric distributed matrices.  Here, \code{a}
and \code{b} must be on the same BLACS context and have the same blocking
dimension.}

\item{...}{additional arguments.}
}
\value{
\code{t()} returns the transposed matrix.

\code{solve()} solves systems and performs matrix inversion when argument
\code{b=} is missing.

\code{La.svd()} performs singular value decomposition, and returns the
transpose of right singular vectors if any are requested. Singular values
are stored as a global R vector. Left and right singular vectors are unique
up to sign. Sometimes core R (via LAPACK) and ScaLAPACK will disagree as to
what the left/right singular vectors are, but the disagreement is always
only up to sign.

\code{svd()} performs singular value decomposition. Differs from
\code{La.svd()} in that the right singular vectors, if requested, are
returned non-transposed. Singular values are stored as a global R vector.
Sometimes core R (via LAPACK) and ScaLAPACK will disagree as to what the
left/right singular vectors are, but the disagreement is always only up to
sign.

\code{eigen()} computes the eigenvalues, and eigenvectors if requested.  As
with \code{svd()}, eigenvalues are stored in a global R vector.

\code{chol()} performs Cholesky factorization.

\code{lu()} performs LU factorization.

\code{solve()} solves systems and performs matrix inversion when argument
\code{b=} is missing.
}
\description{
Linear alegbra functions for distributed matrices with R-like syntax, with
calculations performed by the PBLAS and ScaLAPACK libraries.

Solving linear systems and matrix inversion for distributed matrices with R-like syntax, with
calculations performed by the PBLAS and ScaLAPACK libraries.
}
\details{
Extensions of R linear algebra functions.

Extensions of R linear algebra functions.
}
\section{Methods}{
 \describe{ \item{list("signature(x = \"ddmatrix\")")}{}
\item{list("signature(a = \"ddmatrix\")")}{} \item{list("signature(b =
\"ddmatrix\")")}{} }
}
\examples{
\dontrun{
# Save code in a file "demo.r" and run with 2 processors by
# > mpiexec -np 2 Rscript demo.r

library(pbdDMAT, quiet = TRUE)
init.grid()

# don't do this in production code
x <- matrix(1:9, 3)
x <- as.ddmatrix(x)

y <- solve(t(A) \%*\% A)
print(y)

finalize()
}
\dontrun{
# Save code in a file "demo.r" and run with 2 processors by
# > mpiexec -np 2 Rscript demo.r

library(pbdDMAT, quiet = TRUE)
init.grid()

x <- ddmatrix(1:9, 3)

y <- solve(t(A) \%*\% A)
print(y)

finalize()
}
}
\keyword{Algebra}
\keyword{Linear}
\keyword{Methods}

