% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/pbdDMAT-package.R
\docType{methods}
\name{Extract}
\alias{Extract}
\alias{[}
\alias{[,ddmatrix-method}
\alias{[-method}
\alias{head}
\alias{head.ddmatrix}
\alias{tail}
\alias{tail.ddmatrix}
\title{Extract or Replace Parts of a Distributed Matrix}
\arguments{
\item{x}{numeric distributed matrix.}

\item{i,j}{indices specifying elements to extract or replace.  Indices can
be \code{numeric}, \code{character}, empty, or \code{NULL}.}

\item{n}{a single integer. If positive, size for the resulting object:
number of elements for a vector (including lists), rows for a matrix or data
frame or lines for a function. If negative, all but the \code{n} last/first
number of elements of \code{x}.}

\item{...}{additional arguments.}

\item{ICTXT}{optional BLACS context number for output}
}
\value{
Returns a distributed matrix.
}
\description{
Operators to extract or replace parts of a distributed matrix.
}
\details{
\code{[} can be used to extract/replace for a distributed matrix exactly as
you would with an ordinary matrix.

The functions rely on reblocking across different BLACS contexts.  If
\code{i} is not empty, then the input distributed matrix will be
redistributed along context 1, where extracting/deleting rows does not
destroy block-cyclicality. Likewise, if \code{j} is not empty, then the
input distributed matrix will be redistributed along context 2. When
extraction is complete, the matrix will be redistributed across its input
context.
}
\section{Methods}{
 \describe{ \item{list("signature(x = \"ddmatrix\")")}{} }
}
\examples{
\dontrun{
# Save code in a file "demo.r" and run with 2 processors by
# > mpiexec -np 2 Rscript demo.r

library(pbdDMAT, quiet = TRUE)
init.grid()

# don't do this in production code
x <- matrix(1:9, 3)
x <- as.ddmatrix(x)

y <- x[, -1]
y <- head(y, 2)
print(y)

finalize()
}
}
\keyword{Extraction}
\keyword{Methods}

